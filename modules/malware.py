# modules/malware.py
import os
import math
import subprocess
import platform
import shutil
import json
from datetime import datetime

try:
    from . import vt as vt_api
except Exception:
    vt_api = None

try:
    from . import filescan as filescan_api
except Exception:
    filescan_api = None

# reporting es opcional; si existe usamos present_vt_report u otros helpers
try:
    from . import reporting
except Exception:
    reporting = None


# ----------------------------
# FUNCIONES EXISTENTES
# ----------------------------

def extract_strings(path, min_len=4, max_results=500):
    """Extrae strings ASCII-like del archivo (implementación en Python,
    independiente de herramientas externas)."""
    if not os.path.isfile(path):
        return {"error": "file not found", "path": path}
    results = []
    with open(path, "rb") as f:
        data = f.read()
    cur = bytearray()
    for b in data:
        if 32 <= b <= 126:
            cur.append(b)
        else:
            if len(cur) >= min_len:
                try:
                    results.append(cur.decode("utf-8", errors="ignore"))
                    if len(results) >= max_results:
                        break
                except:
                    pass
            cur = bytearray()
    if len(cur) >= min_len and len(results) < max_results:
        try:
            results.append(cur.decode("utf-8", errors="ignore"))
        except:
            pass
    return {"path": path, "strings_count": len(results), "strings_sample": results[:100]}


def entropy(path):
    """Calcula entropía Shannon del archivo."""
    if not os.path.isfile(path):
        return {"error": "file not found", "path": path}
    with open(path, "rb") as f:
        data = f.read()
    if not data:
        return {"path": path, "entropy": 0.0, "size_bytes": 0}
    freq = {}
    for b in data:
        freq[b] = freq.get(b, 0) + 1
    ent = 0.0
    length = len(data)
    for count in freq.values():
        p = count / length
        ent -= p * math.log2(p)
    return {"path": path, "entropy": ent, "size_bytes": length}


# ----------------------------
# UTILIDADES PARA EJECUTAR COMANDOS
# ----------------------------

def run_system_command(cmd, cwd=None):
    """
    Ejecuta un comando externo y captura stdout/stderr.
    cmd: lista de argumentos (p. ej. ["clamscan", "file"])
    Devuelve dict con command, rc, stdout, stderr o error si no se puede ejecutar.
    """
    # Verificar si el ejecutable existe cuando sea aplicable
    if not cmd:
        return {"error": "empty command"}
    exe = cmd[0]
    # Si el comando es una ruta absoluta, dejamos que subprocess lo intente
    if os.path.isabs(exe) or os.path.sep in exe:
        exe_exists = os.path.exists(exe)
    else:
        exe_exists = shutil.which(exe) is not None

    if not exe_exists:
        return {"command": " ".join(cmd), "error": "executable not found", "exe": exe}

    try:
        proc = subprocess.run(cmd, capture_output=True, text=True, check=False, cwd=cwd)
        return {
            "command": " ".join(cmd),
            "rc": proc.returncode,
            "stdout": proc.stdout.strip(),
            "stderr": proc.stderr.strip()
        }
    except Exception as e:
        return {"command": " ".join(cmd), "error": str(e)}


# ----------------------------
# EJECUCIÓN DE HERRAMIENTAS SEGÚN OS / herramientas individuales
# ----------------------------

def run_malware_tools(target):
    """
    Ejecuta un conjunto de comandos predefinidos para análisis profundo.
    - en Linux: clamscan, rkhunter, lynis, objdump, xxd/hexdump, strace/ltrace, ss/netstat
    - en Windows: clamscan.exe (si existe), sigcheck, dumpbin, strings (Sysinternals), netstat
    Devuelve dict con resultados por comando.
    """
    system = platform.system().lower()
    results = {"target": target, "system": system, "timestamp": datetime.utcnow().isoformat() + "Z", "analyses": []}

    if system == "linux":
        candidates = [
            (["clamscan", target], "clamscan"),
            (["rkhunter", "--check"], "rkhunter"),
            (["lynis", "audit", "system"], "lynis"),
            (["objdump", "-d", target], "objdump"),
            (["xxd", target], "xxd"),
            (["hexdump", "-C", target], "hexdump"),
            (["strace", "-f", "-o", "trace_strace.log", target], "strace"),
            (["ltrace", "-o", "trace_ltrace.log", target], "ltrace"),
            (["ss", "-tulnp"], "ss"),
            (["netstat", "-tulnp"], "netstat"),
        ]
    elif system == "windows":
        # En Windows intentamos ejecutables comunes si están en PATH o rutas absolutas
        candidates = [
            (["clamscan.exe", target], "clamscan.exe"),
            (["sigcheck.exe", target], "sigcheck.exe"),
            (["dumpbin.exe", "/ALL", target], "dumpbin.exe"),
            (["strings.exe", target], "strings.exe"),
            (["netstat", "-ano"], "netstat"),
        ]
    else:
        return {"error": f"OS {system} no soportado"}

    for cmd, name in candidates:
        res = run_system_command(cmd)
        # evitar grandes strings en consola: cortamos stdout a 12k chars en el dict (pero retornamos todo)
        if "stdout" in res and len(res["stdout"]) > 12000:
            res["stdout_preview"] = res["stdout"][:12000] + "\n...[truncated]"
        results["analyses"].append({"tool": name, "result": res})

    return results


def run_tool(tool, target=None):
    """
    Ejecuta una herramienta concreta (para la opción --tool).
    tool: nombre lógico (ej: 'sysstrings','clamscan','objdump','xxd','strace','ss','netstat', etc.)
    target: opción de archivo/host que use la herramienta
    """
    system = platform.system().lower()

    # Mapas básicos de herramientas a comandos
    linux_map = {
        "clamscan": lambda t: ["clamscan", t] if t else ["clamscan", "--version"],
        "rkhunter": lambda t: ["rkhunter", "--check"],
        "lynis": lambda t: ["lynis", "audit", "system"],
        "objdump": lambda t: ["objdump", "-d", t],
        "xxd": lambda t: ["xxd", t],
        "hexdump": lambda t: ["hexdump", "-C", t],
        "strace": lambda t: ["strace", "-f", "-o", "trace_strace.log", t] if t else ["strace", "--version"],
        "ltrace": lambda t: ["ltrace", "-o", "trace_ltrace.log", t] if t else ["ltrace", "--version"],
        "ss": lambda t: ["ss", "-tulnp"],
        "netstat": lambda t: ["netstat", "-tulnp"]
    }
    windows_map = {
        "clamscan": lambda t: ["clamscan.exe", t] if t else ["clamscan.exe", "--version"],
        "sigcheck": lambda t: ["sigcheck.exe", t] if t else ["sigcheck.exe", "-?"],
        "dumpbin": lambda t: ["dumpbin.exe", "/ALL", t] if t else ["dumpbin.exe", "/?"],
        "sysstrings": lambda t: ["strings.exe", t] if t else ["strings.exe", "--help"],
        "netstat": lambda t: ["netstat", "-ano"],
        "powershell_strings": lambda t: ["powershell", "-NoProfile", "-Command", f"Get-Content -Raw -Path '{t}' | Select-String ."] if t else ["powershell", "-NoProfile", "-Command", "Write-Output 'help'"]
    }

    tool_lower = tool.lower()
    if system == "linux":
        if tool_lower not in linux_map:
            return {"error": "tool not supported on linux", "tool": tool}
        cmd = linux_map[tool_lower](target)
    elif system == "windows":
        if tool_lower not in windows_map:
            return {"error": "tool not supported on windows", "tool": tool}
        cmd = windows_map[tool_lower](target)
    else:
        return {"error": "OS not supported", "os": system}

    return {"tool": tool_lower, "command": " ".join(cmd), "result": run_system_command(cmd)}


# ----------------------------
# FUNCIÓN PRINCIPAL run(args)
# ----------------------------

def run(args):
    """
    Punto de entrada del módulo malware.
    Espera que main.py añada los flags:
      --strings (exists)
      --entropy (exists)
      --vt-upload, --vt-hash, --filescan-upload (exists)
      --deep-scan (existe) -> runs predefined battery
      --tool TOOL --target PATH (opcionales) -> ejecutar una herramienta concreta
    """

    # 1) soporte para tool (ej: --tool strings/sysstrings/clamscan/objdump --target <file>)
    tool = getattr(args, "tool", None)
    target = getattr(args, "target", None)
    if tool:
        print(f"[MALWARE] Ejecutando herramienta: {tool} target={target}")
        res = run_tool(tool, target)
        # imprimir resumen para consola
        print(json.dumps(res, indent=2, ensure_ascii=False) if isinstance(res, dict) else str(res))
        # intentar guardar reporte simplificado si reporting lo soporta
        try:
            if reporting and hasattr(reporting, "save_json_report"):
                reporting.save_json_report(res, case_id=getattr(args, "case", None), module="malware", action=f"tool_{tool}")
        except Exception:
            pass
        return res

    # 2) strings (python extractor, mantiene compatibilidad con opciones previas)
    if getattr(args, "strings", None):
        target = args.strings
        res = extract_strings(target)
        if res.get("error"):
            print(f"[MALWARE] ERROR: {res.get('error')} - {res.get('path')}")
            return res
        print(f"[MALWARE] Strings found: {res.get('strings_count')}")
        for s in res.get("strings_sample", [])[:50]:
            print("  ", s)
        # intento de guardado si reporting disponible
        try:
            if reporting and hasattr(reporting, "save_json_report"):
                reporting.save_json_report(res, case_id=getattr(args, "case", None), module="malware", action="strings")
        except Exception:
            pass
        return res

    # 3) entropy
    if getattr(args, "entropy", None):
        target = args.entropy
        res = entropy(target)
        if res.get("error"):
            print(f"[MALWARE] ERROR: {res.get('error')} - {res.get('path')}")
            return res
        print(f"[MALWARE] Entropy: {res.get('entropy'):.4f} bits/byte (size {res.get('size_bytes')} bytes)")
        try:
            if reporting and hasattr(reporting, "save_json_report"):
                reporting.save_json_report(res, case_id=getattr(args, "case", None), module="malware", action="entropy")
        except Exception:
            pass
        return res

    # 4) vt-upload
    if getattr(args, "vt_upload", None):
        target = args.vt_upload
        if not vt_api:
            print("[MALWARE] VirusTotal helper missing (modules/vt.py).")
            return {"error": "vt module missing"}
        print(f"[MALWARE] Uploading to VirusTotal: {target}")
        vt_res = vt_api.upload_file(target, poll_until_complete=True)
        out = getattr(args, "report_format", "both")
        if reporting and hasattr(reporting, "present_vt_report"):
            result = reporting.present_vt_report(
                vt_res, filename_hint=os.path.basename(target),
                case_id=getattr(args, "case", None),
                module="malware", action="vt_upload", output=out
            )
            return result
        else:
            # si no hay reporting, devolver raw
            print("[MALWARE] (vt) returned, printing JSON")
            print(json.dumps(vt_res, indent=2, ensure_ascii=False))
            return vt_res

    # 5) vt-hash
    if getattr(args, "vt_hash", None):
        h = args.vt_hash
        if not vt_api:
            print("[MALWARE] VirusTotal helper missing (modules/vt.py).")
            return {"error": "vt module missing"}
        print(f"[MALWARE] Querying VirusTotal for hash: {h}")
        vt_res = vt_api.get_file_report_by_hash(h)
        out = getattr(args, "report_format", "both")
        if reporting and hasattr(reporting, "present_vt_report"):
            result = reporting.present_vt_report(
                vt_res, filename_hint=None,
                case_id=getattr(args, "case", None),
                module="malware", action="vt_hash_lookup", output=out
            )
            return result
        else:
            print(json.dumps(vt_res, indent=2, ensure_ascii=False))
            return vt_res

       # 6) filescan-upload
    if getattr(args, "filescan_upload", None):
        target = args.filescan_upload
        if not filescan_api:
            print("[MALWARE] FileScan helper missing (modules/filescan.py).")
            return {"error": "filescan module missing"}
        print(f"[MALWARE] Uploading to FileScan.io: {target}")
        fs_res = filescan_api.upload_file(target, poll_until_complete=True)
        out = getattr(args, "report_format", "both")
        if reporting and hasattr(reporting, "present_vt_report"):
            result = reporting.present_vt_report(
                fs_res, filename_hint=os.path.basename(target),
                case_id=getattr(args, "case", None),
                module="malware", action="filescan_upload", output=out
            )
            return result
        else:
            # 🎯 Reporte resumido en consola
            print("[VT] Reporte de análisis")
            print("-" * 40)
            print(f"Archivo: {os.path.basename(target)}")
            sha256 = fs_res.get("sha256") or "N/A"
            detections = fs_res.get("detections") or {}
            total = detections.get("total", 0)
            malicious = detections.get("malicious", 0)
            reputation = fs_res.get("reputation", "N/A")

            print(f"SHA256: {sha256}")
            print(f"Detecciones: {malicious} / {total}")
            print(f"Reputación: {reputation}")

            if total == 0 or malicious == 0:
                print("\n✅ Ningún motor lo marcó como malicioso")
            else:
                print("\n⚠️  El archivo fue marcado como malicioso por algunos motores")

            print("-" * 40)
            return fs_res

    # 7) deep-scan (battery)
    if getattr(args, "deep_scan", None):
        target = args.deep_scan
        if not os.path.isfile(target):
            r = {"error": "file not found", "path": target}
            print(json.dumps(r, indent=2, ensure_ascii=False))
            return r
        print(f"[MALWARE] Ejecutando análisis avanzados (deep-scan) en: {target}")
        res = run_malware_tools(target)
        print(json.dumps(res, indent=2, ensure_ascii=False))
        # guardar si reporting tiene helper
        try:
            if reporting and hasattr(reporting, "save_json_report"):
                reporting.save_json_report(res, case_id=getattr(args, "case", None), module="malware", action="deep_scan")
        except Exception:
            pass
        return res

    # fallback
    help_msg = "[MALWARE] No action especificada. Usa --strings/--entropy/--vt-upload/--vt-hash/--filescan-upload/--deep-scan o --tool <tool> --target <path>"
    print(help_msg)
    return {"error": "no action", "help": help_msg}
